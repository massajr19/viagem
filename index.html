/**
 * TS AI Proxy Worker - v2.0
 * Endpoints:
 *  - GET  /health
 *  - GET  /enrich?q=...&lang=pt
 *  - GET  /lookup?q=...&site=MLB
 *  - GET  /search?q=...&site=MLB&limit=10
 *  - GET  /details?id=...
 *
 * Notes:
 *  - Mercado Livre pode bloquear requests vindos de datacenters/Workers (403). Tratamos isso.
 *  - Wikipedia/Wikidata normalmente funciona bem.
 */

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);

    // CORS preflight
    if (request.method === "OPTIONS") {
      return cors(new Response(null, { status: 204 }));
    }

    try {
      const path = url.pathname.replace(/\/+$/, "") || "/";
      const q = url.searchParams.get("q") || "";
      const lang = (url.searchParams.get("lang") || "pt").toLowerCase();
      const site = (url.searchParams.get("site") || "MLB").toUpperCase();
      const limit = clampInt(url.searchParams.get("limit"), 1, 50, 10);
      const id = url.searchParams.get("id") || "";

      if (path === "/" || path === "/health") {
        return cors(json({ ok: true, name: "tsai-proxy", version: "2.0" }));
      }

      if (path === "/enrich") {
        if (!q.trim()) return cors(json({ ok: true, provider: "wikipedia_wikidata", q, found: false, hint: "Informe q" }));
        const out = await enrichWikipediaWikidata(q, lang);
        return cors(json(out));
      }

      if (path === "/lookup") {
        if (!q.trim()) return cors(json({ ok: false, error: "bad_request", hint: "Informe q" }, 400));
        const out = await mlLookupOne(q, site);
        return cors(json(out, out?.status && out.status !== 200 ? out.status : 200));
      }

      if (path === "/search") {
        if (!q.trim()) return cors(json({ ok: false, error: "bad_request", hint: "Informe q" }, 400));
        const out = await mlSearch(q, site, limit);
        return cors(json(out, out?.status && out.status !== 200 ? out.status : 200));
      }

      if (path === "/details") {
        if (!id.trim()) return cors(json({ ok: false, error: "bad_request", hint: "Informe id" }, 400));
        const out = await mlDetails(id);
        return cors(json(out, out?.status && out.status !== 200 ? out.status : 200));
      }

      return cors(json({ error: "not_found_path" }, 404));
    } catch (err) {
      return cors(json({ error: "server_error", detail: String(err?.message || err) }, 500));
    }
  }
};

function cors(res) {
  const h = new Headers(res.headers);
  h.set("Access-Control-Allow-Origin", "*");
  h.set("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  h.set("Access-Control-Allow-Headers", "Content-Type, Authorization");
  h.set("Access-Control-Max-Age", "86400");
  h.set("Cache-Control", "no-store");
  return new Response(res.body, { status: res.status, headers: h });
}

function json(obj, status = 200) {
  return new Response(JSON.stringify(obj, null, 2), {
    status,
    headers: { "Content-Type": "application/json; charset=utf-8" }
  });
}

function clampInt(v, min, max, def) {
  const n = Number(v);
  if (!Number.isFinite(n)) return def;
  return Math.max(min, Math.min(max, Math.floor(n)));
}

async function fetchJson(url, opts = {}) {
  const res = await fetch(url, {
    ...opts,
    headers: {
      "User-Agent": "tsai-proxy/2.0 (Cloudflare Worker)",
      "Accept": "application/json",
      ...(opts.headers || {})
    }
  });
  let data = null;
  try { data = await res.json(); } catch { /* ignore */ }
  return { res, data };
}

/* ===========================
   Wikipedia + Wikidata
   =========================== */

async function enrichWikipediaWikidata(query, lang = "pt") {
  // 1) Find best title via Opensearch
  const opensearchUrl =
    `https://${lang}.wikipedia.org/w/api.php?action=opensearch&search=${encodeURIComponent(query)}&limit=1&namespace=0&format=json&origin=*`;
  const { res: r1, data: os } = await fetchJson(opensearchUrl);

  if (!r1.ok || !Array.isArray(os) || !Array.isArray(os[1]) || !os[1][0]) {
    return {
      ok: true,
      provider: "wikipedia_wikidata",
      q: query,
      found: false,
      hint: "Falha ao consultar Wikipedia."
    };
  }

  const title = os[1][0];
  const pageUrl = (os[3] && os[3][0]) ? os[3][0] : `https://${lang}.wikipedia.org/wiki/${encodeURIComponent(title.replace(/ /g, "_"))}`;

  // 2) Summary REST
  const summaryUrl =
    `https://${lang}.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(title)}`;
  const { res: r2, data: sum } = await fetchJson(summaryUrl);

  const description = (r2.ok && sum && (sum.extract || sum.description)) ? (sum.extract || sum.description) : "";
  const image =
    (sum?.thumbnail?.source) ||
    (sum?.originalimage?.source) ||
    "";

  // 3) Wikidata ID from pageprops (wikibase_item)
  const pagepropsUrl =
    `https://${lang}.wikipedia.org/w/api.php?action=query&prop=pageprops&titles=${encodeURIComponent(title)}&format=json&origin=*`;
  const { res: r3, data: pp } = await fetchJson(pagepropsUrl);

  let wikidataId = "";
  try {
    const pages = pp?.query?.pages || {};
    const firstKey = Object.keys(pages)[0];
    wikidataId = pages[firstKey]?.pageprops?.wikibase_item || "";
  } catch {}

  let brand = "";
  let manufacturer = "";
  let officialWebsite = "";
  let specs = "";

  const sources = [
    { name: `Wikipedia (${lang})`, url: pageUrl }
  ];

  if (wikidataId) {
    sources.push({ name: "Wikidata", url: `https://www.wikidata.org/wiki/${wikidataId}` });

    const wd = await wikidataExtractBasics(wikidataId);
    brand = wd.brand || "";
    manufacturer = wd.manufacturer || "";
    officialWebsite = wd.officialWebsite || "";

    const parts = [];
    if (brand) parts.push(`Marca: ${brand}`);
    if (manufacturer) parts.push(`Fabricante: ${manufacturer}`);
    if (officialWebsite) parts.push(`Site oficial: ${officialWebsite}`);
    specs = parts.join("\n");
  }

  return {
    ok: true,
    provider: "wikipedia_wikidata",
    q: query,
    found: true,
    title,
    description,
    image,
    pageUrl,
    wikidataId: wikidataId || undefined,
    brand: brand || undefined,
    manufacturer: manufacturer || undefined,
    officialWebsite: officialWebsite || undefined,
    specs: specs || undefined,
    sources
  };
}

async function wikidataExtractBasics(qid) {
  // Use EntityData to get claims, then resolve labels for P1716 (brand) and P176 (manufacturer), P856 (official website)
  const entityUrl = `https://www.wikidata.org/wiki/Special:EntityData/${encodeURIComponent(qid)}.json`;
  const { res, data } = await fetchJson(entityUrl);
  if (!res.ok || !data?.entities?.[qid]) return {};

  const ent = data.entities[qid];
  const claims = ent.claims || {};

  const brandQ = firstEntityClaimId(claims, "P1716");       // brand
  const manufQ = firstEntityClaimId(claims, "P176");       // manufacturer
  const website = firstStringClaim(claims, "P856");        // official website

  const ids = [brandQ, manufQ].filter(Boolean);
  const labels = ids.length ? await wikidataLabels(ids) : {};

  return {
    brand: brandQ ? (labels[brandQ] || "") : "",
    manufacturer: manufQ ? (labels[manufQ] || "") : "",
    officialWebsite: website || ""
  };
}

function firstEntityClaimId(claims, pid) {
  const arr = claims?.[pid];
  if (!Array.isArray(arr) || !arr[0]?.mainsnak?.datavalue?.value?.id) return "";
  return arr[0].mainsnak.datavalue.value.id;
}

function firstStringClaim(claims, pid) {
  const arr = claims?.[pid];
  if (!Array.isArray(arr) || !arr[0]?.mainsnak?.datavalue?.value) return "";
  return String(arr[0].mainsnak.datavalue.value);
}

async function wikidataLabels(ids) {
  // fetch labels in pt, fallback en
  const url =
    `https://www.wikidata.org/w/api.php?action=wbgetentities&ids=${encodeURIComponent(ids.join("|"))}&props=labels&languages=pt|en&format=json&origin=*`;
  const { res, data } = await fetchJson(url);
  if (!res.ok) return {};

  const out = {};
  for (const id of ids) {
    const e = data?.entities?.[id];
    const lbl = e?.labels?.pt?.value || e?.labels?.en?.value || "";
    out[id] = lbl;
  }
  return out;
}

/* ===========================
   Mercado Livre (Shopping)
   =========================== */

async function mlSearch(query, site = "MLB", limit = 10) {
  const searchUrl =
    `https://api.mercadolibre.com/sites/${encodeURIComponent(site)}/search?q=${encodeURIComponent(query)}&limit=${encodeURIComponent(limit)}`;

  const { res, data } = await fetchJson(searchUrl);

  if (res.status === 403) {
    return {
      error: "ml_blocked",
      status: 403,
      hint: "O Mercado Livre bloqueou/limitou este acesso (comum em Workers/datacenters). Tente novamente mais tarde ou refine a busca.",
      debug: { q: query, site, searchUrl }
    };
  }

  if (!res.ok || !data) {
    return {
      error: "ml_error",
      status: res.status,
      hint: "Falha ao consultar Mercado Livre.",
      debug: { q: query, site, searchUrl }
    };
  }

  const items = Array.isArray(data.results) ? data.results.slice(0, limit).map(r => ({
    id: r.id,
    title: r.title,
    priceBRL: (r.currency_id === "BRL" ? r.price : r.price), // para MLB geralmente BRL
    thumbnail: r.thumbnail,
    url: r.permalink,
    seller: r.seller?.nickname || undefined,
    soldQty: r.sold_quantity || undefined,
    source: "Mercado Livre"
  })) : [];

  return { ok: true, provider: "mercadolibre", q: query, site, items };
}

async function mlDetails(id) {
  const itemUrl = `https://api.mercadolibre.com/items/${encodeURIComponent(id)}`;
  const { res, data } = await fetchJson(itemUrl);

  if (res.status === 403) {
    return {
      error: "ml_blocked",
      status: 403,
      hint: "O Mercado Livre bloqueou/limitou este acesso (comum em Workers/datacenters). Tente novamente mais tarde.",
      debug: { id, itemUrl }
    };
  }

  if (!res.ok || !data) {
    return {
      error: "ml_error",
      status: res.status,
      hint: "Falha ao buscar detalhes do item no Mercado Livre.",
      debug: { id, itemUrl }
    };
  }

  const pics = Array.isArray(data.pictures) ? data.pictures.map(p => p.secure_url || p.url).filter(Boolean) : [];
  const attrs = Array.isArray(data.attributes) ? data.attributes : [];

  const brand = pickAttr(attrs, ["BRAND", "MARCA", "Marca"]);
  const model = pickAttr(attrs, ["MODEL", "MODELO", "Modelo"]);
  const storage = pickAttr(attrs, ["INTERNAL_MEMORY", "CAPACIDADE", "Armazenamento", "STORAGE_CAPACITY"]);
  const color = pickAttr(attrs, ["COLOR", "Cor", "COLOR_NAME"]);

  const specsParts = [];
  if (brand) specsParts.push(`Marca: ${brand}`);
  if (model) specsParts.push(`Modelo: ${model}`);
  if (storage) specsParts.push(`Armazenamento: ${storage}`);
  if (color) specsParts.push(`Cor: ${color}`);

  // coloca mais alguns atributos Ãºteis (top 10) sem poluir muito
  const extra = attrs
    .filter(a => a?.value_name && a?.name)
    .slice(0, 10)
    .map(a => `${a.name}: ${a.value_name}`);

  const specs = [...specsParts, ...(extra.length ? ["", "Atributos:", ...extra] : [])].join("\n").trim();

  const priceBRL = (data.currency_id === "BRL") ? data.price : data.price;

  return {
    ok: true,
    provider: "mercadolibre",
    item: {
      id: data.id,
      title: data.title,
      priceBRL,
      currency: data.currency_id,
      url: data.permalink,
      brand: brand || undefined,
      manufacturer: brand || undefined,
      images: pics,
      image: pics?.[0] || data.thumbnail || undefined,
      specs: specs || undefined
    }
  };
}

function pickAttr(attrs, keys) {
  const keysUpper = keys.map(k => String(k).toUpperCase());
  for (const a of attrs) {
    const id = String(a?.id || "").toUpperCase();
    const name = String(a?.name || "").toUpperCase();
    if (keysUpper.includes(id) || keysUpper.includes(name)) {
      if (a?.value_name) return a.value_name;
    }
  }
  return "";
}

async function mlLookupOne(query, site = "MLB") {
  const searchUrl =
    `https://api.mercadolibre.com/sites/${encodeURIComponent(site)}/search?q=${encodeURIComponent(query)}&limit=1`;

  const { res, data } = await fetchJson(searchUrl);

  if (res.status === 403) {
    return {
      error: "ml_blocked",
      status: 403,
      hint: "O Mercado Livre bloqueou/limitou este acesso (comum em Workers/datacenters). Tente novamente em alguns minutos ou refine a busca.",
      debug: { q: query, site, searchUrl }
    };
  }

  if (!res.ok || !data) {
    return {
      error: "ml_error",
      status: res.status,
      hint: "Falha ao consultar Mercado Livre.",
      debug: { q: query, site, searchUrl }
    };
  }

  const r0 = Array.isArray(data.results) ? data.results[0] : null;
  if (!r0) return { error: "not_found", status: 404, hint: "Nenhum item encontrado.", debug: { q: query, site, searchUrl } };

  return {
    ok: true,
    provider: "mercadolibre",
    q: query,
    site,
    item: {
      id: r0.id,
      title: r0.title,
      priceBRL: (r0.currency_id === "BRL") ? r0.price : r0.price,
      url: r0.permalink,
      thumbnail: r0.thumbnail
    }
  };
}
